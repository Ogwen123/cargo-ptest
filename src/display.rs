use crate::parse::{GeneralTestType, ParsedTestGroup, Status, Summary};
use std::ops::Add;

pub trait Colourise: ToString {
    /// Colour the output to be green using ANSI codes.
    fn green(&self) -> String;
    /// Colour the output to be red using ANSI codes.
    fn red(&self) -> String;
    /// Colour the output to be yellow using ANSI codes.
    fn yellow(&self) -> String;
    /// Colour the output to be blue using ANSI codes.
    fn blue(&self) -> String;
}

impl Colourise for &str {
    fn green(&self) -> String {
        String::from("\x1b[32m") + &*self.to_string() + "\x1b[0m"
    }

    fn red(&self) -> String {
        String::from("\x1b[31m") + &*self.to_string() + "\x1b[0m"
    }

    fn yellow(&self) -> String {
        String::from("\x1b[33m") + &*self.to_string() + "\x1b[0m"
    }

    fn blue(&self) -> String {
        String::from("\x1b[34m") + &*self.to_string() + "\x1b[0m"
    }
}

impl Colourise for String {
    fn green(&self) -> String {
        String::from("\x1b[32m") + self + "\x1b[0m"
    }

    fn red(&self) -> String {
        String::from("\x1b[31m") + self + "\x1b[0m"
    }

    fn yellow(&self) -> String {
        String::from("\x1b[33m") + self + "\x1b[0m"
    }

    fn blue(&self) -> String {
        String::from("\x1b[34m") + self + "\x1b[0m"
    }
}

pub enum Colour {
    GREEN,
    RED,
    ORANGE,
}

/// Corresponds to the display function defined in [Display]
pub enum DisplayType {
    /// Outputs data as a tree, grouped by crate -> file -> module -> etc
    Tree,
    /// Outputs data without any indentation or grouping
    Linear,
    /// WIP Outputs data as in JSON for easy consumption by other tools.
    Json,
}

pub enum Pipes {
    T,
    L,
    Vertical,
    Horizontal,
}

impl Pipes {
    fn d(&self) -> String {
        // keep the method name short to not clutter the display functions
        match self {
            Pipes::T => String::from("├"),
            Pipes::L => String::from("└"),
            Pipes::Vertical => String::from("│"),
            Pipes::Horizontal => String::from("─"),
        }
    }
}

pub struct StringBuilder {
    lines: Vec<String>,
    /// a string to be added to the start of each line that is added through add()
    prefix: String,
    /// a string to be added to the end of each line that is added through add(), e.g. \n
    suffix: String,
}

/// A struct for simplifying building output strings.
impl StringBuilder {
    /// Initial message will be printed at the top of the output.
    /// Prefix and suffix will be added to all lines added through [add()].
    fn new<A, B, C>(initial_message: A, prefix: B, suffix: C) -> Self
    where
        A: ToString,
        B: ToString,
        C: ToString,
    {
        StringBuilder {
            lines: vec![initial_message.to_string()],
            prefix: prefix.to_string(),
            suffix: suffix.to_string(),
        }
    }

    /// Adds lines to the StringBuilder
    fn add<T>(&mut self, line: T)
    where
        T: ToString + AsRef<str>,
    {
        self.lines.push(
            self.prefix
                .clone()
                .add(line.as_ref())
                .add(self.suffix.as_str()),
        )
    }

    /// Adds a string without adding the prefix or suffix.
    fn add_raw<T>(&mut self, line: T)
    where
        T: ToString + AsRef<str>,
    {
        self.lines.push(line.to_string())
    }

    /// Outputs the string.
    fn string(&self) -> String {
        self.lines.join("")
    }
}

/// Takes the output from [parse::parse] and handles displaying it to the console in different forms.
pub struct Display {
    /// Displayed at the top of the output
    initial_message: String,
    /// This is the output taken from [parse::parse]
    test_groups: Vec<ParsedTestGroup>,
}

impl Display {
    pub fn new(initial_message: &str, parsed: Vec<ParsedTestGroup>) -> Display {
        Display {
            initial_message: initial_message.to_string(),
            test_groups: parsed,
        }
    }

    /// deprecated
    pub fn colour(c: Colour, s: &str) -> String {
        String::from("test")
    }

    /// WIP
    pub fn tree(&self) -> String {
        String::new()
    }

    /// Outputs all the tests without and indentation or formatting
    /// ``` text
    ///Generated by ptest
    /// ├ Ignored - tests::tests::should_panic_and_does
    /// ├ Failed - tests::tests2::panic - See reason below
    /// ├ Pass - tests::tests2::succeed
    /// ├ Pass - tests::tests::succeed
    /// ├ Failed - tests::tests::should_panic_and_doesnt - See reason below
    /// ├ Failed - tests::tests::panic - See reason below
    /// ├ Pass - colour_test_green
    /// ├ Pass - colour_test_red
    /// ├ Ignored - submod::ignore (this is the reason)
    /// ├ Ignored - submod::ignore_without_reason
    /// ├ Pass - submod::normal_test
    /// ├ Pass - submod::panic::should_panic
    /// ├ Failed - submod::panic::should_panic_but_didnt - See reason below
    /// ├ Failed - submod::panic::panicked - See reason below
    /// ├ Pass - submod::panic::should_panic_without_reason
    /// ├ Pass - works
    /// ├ Pass - from_main_rs
    /// ├ Pass - from_integration
    /// ├ Ignored - attribute::ignore from tests/integration/src/lib.rs   Doc-test
    /// ├ Pass - attribute::no_run from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass -  from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - normal_doc_mod from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - empty_doc_mod::private_mod from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - empty_doc_mod from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - normal_doc_mod::private_mod::Item from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - attribute::should_panic from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - normal_doc_mod::Item from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - empty_doc_mod::Item from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - normal_doc_mod::private_mod from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - attribute::edition2018 from tests/integration/src/lib.rs  Doc-test
    /// ├ Pass - attribute::should_compile_fail from tests/integration/src/lib.rs  Doc-test
    /// ├ Failed - attribute::should_compile_fail_but_didnt from tests/integration/src/lib.rs - See reason below  Doc-test
    ///
    /// test result: FAILED. 10 Passed; 5 Failed; 3 Ignored; 0 Measured; 0 Filtered; finished in 0.00s
    /// ```
    pub fn linear(&self) -> String {
        let mut sb: StringBuilder = StringBuilder::new(
            self.initial_message.clone() + "\n",
            Pipes::T.d() + " ",
            "\n",
        );

        let mut total_summary: Summary = Summary::default();

        for group in &self.test_groups {
            for test in group.tests.clone() {
                if test.test_type == GeneralTestType::Normal {
                    if test.status == Status::Passed {
                        sb.add(format!("{} - {}", "Pass".green(), test.module_path))
                    } else if test.status == Status::Ignored {
                        sb.add(format!(
                            "{} - {} {}",
                            "Ignored".yellow(),
                            test.module_path,
                            test.ignore_reason
                                .clone()
                                .map_or("".to_string(), |x| format!("({})", x)),
                        ))
                    } else if test.status == Status::Failed {
                        sb.add(format!(
                            "{} - {} - See reason below",
                            "Failed".red(),
                            test.module_path
                        ))
                    }
                } else {
                    if test.status == Status::Passed {
                        sb.add(format!(
                            "{} - {} from {} {}",
                            "Pass".green(),
                            test.module_path,
                            test.file_path.map_or("ERROR".to_string(), |x| x),
                            " Doc-test".blue()
                        ))
                    } else if test.status == Status::Ignored {
                        sb.add(format!(
                            "{} - {} from {} {} {}",
                            "Ignored".yellow(),
                            test.module_path,
                            test.file_path.map_or("ERROR".to_string(), |x| x),
                            test.ignore_reason
                                .clone()
                                .map_or("".to_string(), |x| format!("({})", x)),
                            " Doc-test".blue()
                        ))
                    } else if test.status == Status::Failed {
                        sb.add(format!(
                            "{} - {} from {} - See reason below {}",
                            "Failed".red(),
                            test.module_path,
                            test.file_path.map_or("ERROR".to_string(), |x| x),
                            " Doc-test".blue()
                        ))
                    }
                }
            }
            if let Some(summary) = group.summary.clone() {
                total_summary += summary
            }
        }
        sb.add_raw("\n");
        sb.add_raw(total_summary.to_string());
        sb.string()
    }

    /// WIP
    pub fn json(&self) -> String {
        String::new()
    }

    /// Calls the requested display function and prints the result
    pub fn display(&self, _type: DisplayType) {
        match _type {
            DisplayType::Tree => println!("{}", self.tree()),
            DisplayType::Linear => println!("{}", self.linear()),
            DisplayType::Json => println!("{}", self.json()),
        }
    }
}
